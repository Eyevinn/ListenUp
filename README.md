# ListenUp by Eyevinn

ListenUp is a java library used for reducing boilerplate code related to listeners. 
It is available as a maven artifact at [https://jitpack.io](https://jitpack.io/#Eyevinn/ListenUp) 
and can be used with both java and Android projects.

## Background


## Add to project
ListenUp consists of two modules:  
* `ListenUp/ListenUp` - Java library
* `ListenUp/ListenUp-processor` - Annotation processor

### Using Gradle 5.0+
Add the following to your `build.gradle` file:
```gradle
...

repositories {
	maven { url "https://jitpack.io" }
	...
}

...
dependencies {
	...
	implementation 'com.github.Eyevinn.ListenUp:ListenUp:1.0'
	annotationProcessor 'com.github.Eyevinn.ListenUp:ListenUp-processor:1.0'
}
...
```

## Usage examples

```java
...
import se.eyevinn.listenup.annotation.Listener;

@Listener
public interface IDownloadListener {
	void onDownloadStarted(long downloadId);
	void onDownloadProgress(long downloadId, long additionalBytesDownloaded);
	void onDownloadFinished(long downloadId);
}
```
When the project is built ListenUp will generate a set of implementations of the 
`IDownloadListener` since it is annotated with the `@Listener` annotation.

We implement a `Downloader` class to handle actual downloads. Without ListenUp this class also
needs to handle a collection of listeners and loop through them to fire events etc. ListenUp takes
care of this boilerplate code by generating a class called `DownloadListenerEventDispatcher`:
```java
import listenup.generated.event.DownloadListenerEventDispatcher;
import se.eyevinn.listenup.event.IEventSource;

public class Downloader implements IEventSource<IDownloadListener>{
	private final DownloadListenerEventDispatcher dispatcher; // <-- Class generated by ListenUp! 

	public Downloader() {
		this.dispatcher = new DownloadListenerEventDispatcher();
	}

	@Override
	public boolean addListener(IDownloadListener listener) {
		return dispatcher.addListener(listener);
	}

	@Override
	public boolean removeListener(IDownloadListener listener) {
		return dispatcher.removeListener(listener);
	}
	
	public void simulateDownload() {
		long downloadId = (long) (Math.random()*Long.MAX_VALUE);
		dispatcher.fireOnDownloadStarted(downloadId); // <-- Methods generated by ListenUp
		for(int i = 0; i < 100; ++i) {
			dispatcher.fireOnDownloadProgress(downloadId, (long) (Math.random()*256));
		}
		dispatcher.fireOnDownloadFinished(downloadId);
	}
}
```

For more available generated classes see [Architecture and types](#architecture-and-types).


## Architecture and types

### Basic types according to ListenUp

#### Listener types
A listener is any type that represents a listener interface. 
This means that it can listen to a set of 'events' (see below).

The following restrictions apply to listener types:
* Must be an interface
* Must only have methods that return void. These are the 'events'.

#### Events
An event is a conceptual object that can be listened for by a listener. 
For a listener type `L` an event class implements the interface `IEvent<L>`. 
Typically, event classes are not directly used. Instead they are represented 
by method calls to void-returning methods on a listener interface.
For example:  
```java
public interface IListener {
	void onEvent1(); // <-- Represents event1
	void onEvent2(int data, String message); // <-- Represents event2
}
```
Event objects can contain additional data. This is represented in the example above as method parameters.

#### Event sources
An event source for a listener type `L`, implements the interface `IEventSource<L>`. 
Conceptually an event source creates events and sends them to attached listeners. 
In practice it is simply something that can be listened to by a listener of type L. 
```
public interface IEventSource<L> {
	boolean addListener(L listener);
	boolean removeListener(L listener);
}
```

### Using the `@Listener` annotation

To make ListenUp generate files, simply add the `@Listener` annotation to your listener type.
```java
@Listener
public interface IListener {
	void onEvent1();
	void onEvent2(int data, String message);
}
```
This will generate a set of implementations and associated classes for our listener.

To control which classes are generated we can set the `generate` and/or `dontGenerate` attributes of 
the `@Listener` annotation. These attributes define a list of `se.eyevinn.listenup.annotation.ListenerType` enums,
corresponding to different generated classes.

The default value for `generate` is `generate={ListenerType.ALL}` which makes ListenUp generate all 
currently supported implementations and associated classes for our listener. If we want to choose
which get generated we instead list them.

For example,
```java
@Listener(generate= {ListenerType.BASE, ListenerType.LOGGER})
public interface IExampleListener {
	void onPing();
	void onMessage(String message);
}
```
will only result in `BaseExampleListener` and `LoggingExampleListener` being generated.
```java
// File generated by ListenUp!
public abstract class BaseExampleListener implements IExampleListener {
    @Override
    public void onPing() {
        // Unhandled
    }
    @Override
    public void onMessage(String message) {
        // Unhandled
    }
}
``` 
```java
// File generated by ListenUp!
public class LoggingExampleListener implements IExampleListener {

    /**
     * Override this to handle conversation to String.
     */
    protected String _internal_toString(Object object) {
        return String.valueOf(object);
    }

    /**
     * Override this to handle logging.
     */
    protected void _internal_log(String message) {
        System.out.println(message);
    }

    @Override
    public void onPing() {
        StringBuilder message = new StringBuilder("onPing(");
        message.append(")");
        _internal_log(message.toString());
    }

    @Override
    public void onMessage(String message) {
        StringBuilder message0 = new StringBuilder("onMessage(");
        message0.append(_internal_toString(message));
        message0.append(")");
        _internal_log(message0.toString());
    }
}
```

If we instead want to exclude a set of generated files we can provide the `dontGenerate` attribute:
```java
@Listener(dontGenerate= {ListenerType.LOGGER, ListenerType.DISPATCHER})
public interface IExampleListener {
	void onPing();
	void onMessage(String message);
}
```
This will generate everything *except* `LoggingExampleListener` and `ExampleListenerEventDispatcher`.

#### Options
Some of the generated `ListenerType`s have additional options. These can be set by adding an options annotations
(different annotations for each `ListenerType`). All such annotations are located in the 
`se.eyevinn.listenup.annotation.options` package.

For example,
```java
@Listener
@LoggerOptions(logMethodName="log", toStringMethodName="convertToString")
public interface IDogListener {
	void onWoof(Woof woof);
}
```
will generate
```java
public class LoggingDogListener implements IDogListener {

    /**
     * Override this to handle conversation to String.
     */
    protected String convertToString(Object object) { // <-- Note method name
        return String.valueOf(object);
    }

    /**
     * Override this to handle logging.
     */
    protected void log(String message) { // <-- Note method name
        System.out.println(message);
    }

    @Override
    public void onWoof(Woof woof) {
        StringBuilder message = new StringBuilder("onWoof(");
        message.append(convertToString(woof));
        message.append(")");
        log(message.toString());
    }
}
```

These can be used to avoid name-clashes or general naming preferences.

### Generated types

In the descriptions below, `L` is used as a placeholder for the annotated 
listener type and `${listenerName}` for it's simple name. 
 
---
#### `ListenerType.BASE`
```
	Name pattern: Base${listenerName}
	ImplementedInterfaces: L
	Options annotation: N/A 
```
Generates an abstract "base implementation" where all events are unhandled be default. By extending 
this class users can choose which subset of events to listen to.

Example:
```java
eventSource.addListener(new BaseListenerWithManyEvents() {
	@Override
	public void onInterestingEvent(String data) {
		//TODO handle
	}
});
```
 
---
#### `ListenerType.LOGGER`
```
	Name pattern: Logging${listenerName}
	ImplementedInterfaces: L
	Options annotation: se.eyevinn.listenup.annotation.options.LoggerOptions 
```
Generates a listener implementation that logs every event to the console (`System.out`). 
Useful for debugging.

If we want to change the logging from `System.out` to a different target (which is often the case for Android)
we can override the internal log-method.`

Example for Android:
```
messageSource.addListener(new LoggingMessageListener() {
	@Override
	protected void _internal_log(String message) {
		Log.d(TAG, message);
	}
});
```

##### LoggerOptions
* `logMethodName` - Specifies the name used for the internal log method.
* `toStringMethodName` - Specifies the name used for converting event parameters to Strings. 
 
---
#### `ListenerType.BROADCASTER`
```
	Name pattern: ${listenerName}EventBroadcaster
	ImplementedInterfaces: L, IEventSource<L>
	Options annotation: N/A
```
Generates a listener that is also an event source. Whenever it receives an event it propagates it
to all it's listeners. This can be used to dispatch events, or `fan out` events.

---
#### `ListenerType.DISPATCHER`
```
	Name pattern: ${listenerName}EventDispatcher
	ImplementedInterfaces: IEventSource<L>
	Options annotation: se.eyevinn.listenup.annotation.options.DispatcherOptions 
```
Generates an event dispatcher, very similar to the `ListenerType.BROADCAST`. The difference is that
the dispatcher is not itself a listener. This can help make code that dispatches events more understandable.
Typically

The dispatcher contains dispatch-methods for each event.

For example for,  
```java
@Listener
public interface IExampleListener {
	void onPing();
	void onMessage(String message);
}
```
ListenUp will generate `ExampleListenerEventDispatcher` with the methods
* `public void fireOnPing () { ...}`
* `public void fireOnMessage (String message) { ...}`

These can then be called to send events to all attached listeners.
```java
public class SomeUsefulClass implements IEventSource<IExampleListener> {
	private final ExampleListenerEventDispatcher dispatcher = new ExampleListenerEventDispatcher();
	...
	
	@Override
	public boolean addListener(IExampleListener listener) {
		return dispatcher.addListener(listener);
	}
	
	@Override
	public boolean removeListener(IExampleListener listener) {
		return dispatcher.removeListener(listener);
	}
	
	public void doStuff() {
		...
		dispatcher.fireOnPing();
		...
	}
}
```

##### DispatcherOptions
* `fireEventPrefix` - Specifies the prefix used for dispatch methods.
* `stripOnPrefix` - If `true`, dispatch methods are named based on the event name without any leading 'on/On'. Events not beginning with 'on' are unaffected.

Example:
```java
@Listener
@DispatcherOptions(stripOnPrefix=true)
public interface IExampleListener {
	void onPing();
	void onMessage(String message);
}
```
generates dispatcher methods `firePing()` and `fireMessage(String message)`.

Example:
```java
@Listener
@DispatcherOptions(fireEventPrefix="dispatch")
public interface IExampleListener {
	void onPing();
	void onMessage(String message);
}
```
generates methods `dispatchOnPing` and `dispatchOnMessage(String message)`.

---
#### `ListenerType.BUFFER`
```
	Name pattern: Buffering${listenerName}
	ImplementedInterfaces: L
	Options annotation: se.eyevinn.listenup.annotation.options.BufferOptions 
```
Generates a listener that stores received events in a buffer. These events can be later be handled by
a different listener by calling the releaseBuffer-method. This is can be used by an analytics collector
to avoid sending events over HTTP as soon as they are received, but instead put the in a buffer and then
send periodically in the same network call.

Example: 
```java
@Listener
public interface IUserListener {
	void onPageNavigation(String oldPage, String newPage);
	void onLinkClicked(String link);
	void onLogOut();
}
```
```java
public void UserAnalyticsListener extends BufferingUserListener {
	public void sendCollectedData(PayloadReceiver target) {
		final PayloadBuilder payload = new PayloadBuilder();
		releaseBuffer(new BaseUserListener() {
			@Override
			public void onPageNavigation(String oldPage, String newPage) {
				payload.addEvent("pageNav", oldPage+"->"+newPage);
			}
			...
			//etc.
		});
		target.sendPayload(payload.build());
	}
}
```

##### BufferOptions
* `releaseBufferMethodName` - Specifies the name used for the release buffer method.